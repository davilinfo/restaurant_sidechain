{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst BigNum = require(\"@liskhq/bignum\");\n\nconst cryptography = require(\"@liskhq/lisk-cryptography\");\n\nconst constants_1 = require(\"../../constants\");\n\nexports.validatePublicKey = publicKey => {\n  const publicKeyBuffer = cryptography.hexToBuffer(publicKey);\n\n  if (publicKeyBuffer.length !== constants_1.MAX_PUBLIC_KEY_LENGTH) {\n    throw new Error(`Public key ${publicKey} length differs from the expected 32 bytes for a public key.`);\n  }\n\n  return true;\n};\n\nexports.isNullByteIncluded = input => new RegExp('\\\\0|\\\\U00000000').test(input);\n\nexports.validateUsername = username => {\n  if (exports.isNullByteIncluded(username)) {\n    return false;\n  }\n\n  if (username !== username.trim().toLowerCase()) {\n    return false;\n  }\n\n  if (/^[0-9]{1,21}[L|l]$/g.test(username)) {\n    return false;\n  }\n\n  if (!/^[a-z0-9!@$&_.]+$/g.test(username)) {\n    return false;\n  }\n\n  return true;\n};\n\nexports.validateSignature = signature => /^[a-f0-9]{128}$/i.test(signature);\n\nexports.checkPublicKeysForDuplicates = publicKeys => publicKeys.every((element, index) => {\n  if (publicKeys.slice(index + 1).includes(element)) {\n    throw new Error(`Duplicated public key: ${publicKeys[index]}.`);\n  }\n\n  return true;\n});\n\nexports.stringEndsWith = (target, suffixes) => suffixes.some(suffix => target.endsWith(suffix));\n\nexports.validatePublicKeys = publicKeys => publicKeys.every(exports.validatePublicKey) && exports.checkPublicKeysForDuplicates(publicKeys);\n\nexports.validateKeysgroup = keysgroup => {\n  if (keysgroup.length < constants_1.MULTISIGNATURE_MIN_KEYSGROUP || keysgroup.length > constants_1.MULTISIGNATURE_MAX_KEYSGROUP) {\n    throw new Error(`Expected between ${constants_1.MULTISIGNATURE_MIN_KEYSGROUP} and ${constants_1.MULTISIGNATURE_MAX_KEYSGROUP} public keys in the keysgroup.`);\n  }\n\n  return exports.validatePublicKeys(keysgroup);\n};\n\nconst MIN_ADDRESS_LENGTH = 2;\nconst MAX_ADDRESS_LENGTH = 22;\nconst BASE_TEN = 10;\n\nexports.validateAddress = address => {\n  if (address.length < MIN_ADDRESS_LENGTH || address.length > MAX_ADDRESS_LENGTH) {\n    throw new Error('Address length does not match requirements. Expected between 2 and 22 characters.');\n  }\n\n  if (address[address.length - 1] !== 'L') {\n    throw new Error('Address format does not match requirements. Expected \"L\" at the end.');\n  }\n\n  if (address.includes('.')) {\n    throw new Error('Address format does not match requirements. Address includes invalid character: `.`.');\n  }\n\n  const addressString = address.slice(0, -1);\n  const addressNumber = new BigNum(addressString);\n\n  if (addressNumber.cmp(new BigNum(constants_1.MAX_ADDRESS_NUMBER)) > 0) {\n    throw new Error('Address format does not match requirements. Address out of maximum range.');\n  }\n\n  if (addressString !== addressNumber.toString(BASE_TEN)) {\n    throw new Error(\"Address string format does not match it's number representation.\");\n  }\n\n  return true;\n};\n\nexports.isGreaterThanZero = amount => amount.cmp(0) > 0;\n\nexports.isGreaterThanOrEqualToZero = amount => amount.cmp(0) >= 0;\n\nexports.isGreaterThanMaxTransactionAmount = amount => amount.cmp(constants_1.MAX_TRANSACTION_AMOUNT) > 0;\n\nexports.isGreaterThanMaxTransactionId = id => id.cmp(constants_1.MAX_TRANSACTION_ID) > 0;\n\nexports.isNumberString = str => {\n  if (typeof str !== 'string') {\n    return false;\n  }\n\n  return /^[0-9]+$/g.test(str);\n};\n\nexports.validateNonTransferAmount = data => exports.isNumberString(data) && data === '0';\n\nexports.validateTransferAmount = data => exports.isNumberString(data) && exports.isGreaterThanZero(new BigNum(data)) && !exports.isGreaterThanMaxTransactionAmount(new BigNum(data));\n\nexports.isValidTransferData = data => Buffer.byteLength(data, 'utf8') <= constants_1.MAX_TRANSFER_ASSET_DATA_LENGTH;\n\nexports.validateFee = data => exports.isNumberString(data) && exports.isGreaterThanOrEqualToZero(new BigNum(data)) && !exports.isGreaterThanMaxTransactionAmount(new BigNum(data));\n\nexports.isValidInteger = num => typeof num === 'number' ? Math.floor(num) === num : false;\n\nexports.isUnique = values => {\n  const unique = [...new Set(values)];\n  return unique.length === values.length;\n};\n\nexports.isValidNumber = num => {\n  if (typeof num === 'number') {\n    return true;\n  }\n\n  if (typeof num === 'string') {\n    return exports.isNumberString(num);\n  }\n\n  return false;\n};","map":{"version":3,"sources":["../../../src/utils/validation/validation.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst BigNum = require(\"@liskhq/bignum\");\r\nconst cryptography = require(\"@liskhq/lisk-cryptography\");\r\nconst constants_1 = require(\"../../constants\");\r\nexports.validatePublicKey = (publicKey) => {\r\n    const publicKeyBuffer = cryptography.hexToBuffer(publicKey);\r\n    if (publicKeyBuffer.length !== constants_1.MAX_PUBLIC_KEY_LENGTH) {\r\n        throw new Error(`Public key ${publicKey} length differs from the expected 32 bytes for a public key.`);\r\n    }\r\n    return true;\r\n};\r\nexports.isNullByteIncluded = (input) => new RegExp('\\\\0|\\\\U00000000').test(input);\r\nexports.validateUsername = (username) => {\r\n    if (exports.isNullByteIncluded(username)) {\r\n        return false;\r\n    }\r\n    if (username !== username.trim().toLowerCase()) {\r\n        return false;\r\n    }\r\n    if (/^[0-9]{1,21}[L|l]$/g.test(username)) {\r\n        return false;\r\n    }\r\n    if (!/^[a-z0-9!@$&_.]+$/g.test(username)) {\r\n        return false;\r\n    }\r\n    return true;\r\n};\r\nexports.validateSignature = (signature) => /^[a-f0-9]{128}$/i.test(signature);\r\nexports.checkPublicKeysForDuplicates = (publicKeys) => publicKeys.every((element, index) => {\r\n    if (publicKeys.slice(index + 1).includes(element)) {\r\n        throw new Error(`Duplicated public key: ${publicKeys[index]}.`);\r\n    }\r\n    return true;\r\n});\r\nexports.stringEndsWith = (target, suffixes) => suffixes.some(suffix => target.endsWith(suffix));\r\nexports.validatePublicKeys = (publicKeys) => publicKeys.every(exports.validatePublicKey) &&\r\n    exports.checkPublicKeysForDuplicates(publicKeys);\r\nexports.validateKeysgroup = (keysgroup) => {\r\n    if (keysgroup.length < constants_1.MULTISIGNATURE_MIN_KEYSGROUP ||\r\n        keysgroup.length > constants_1.MULTISIGNATURE_MAX_KEYSGROUP) {\r\n        throw new Error(`Expected between ${constants_1.MULTISIGNATURE_MIN_KEYSGROUP} and ${constants_1.MULTISIGNATURE_MAX_KEYSGROUP} public keys in the keysgroup.`);\r\n    }\r\n    return exports.validatePublicKeys(keysgroup);\r\n};\r\nconst MIN_ADDRESS_LENGTH = 2;\r\nconst MAX_ADDRESS_LENGTH = 22;\r\nconst BASE_TEN = 10;\r\nexports.validateAddress = (address) => {\r\n    if (address.length < MIN_ADDRESS_LENGTH ||\r\n        address.length > MAX_ADDRESS_LENGTH) {\r\n        throw new Error('Address length does not match requirements. Expected between 2 and 22 characters.');\r\n    }\r\n    if (address[address.length - 1] !== 'L') {\r\n        throw new Error('Address format does not match requirements. Expected \"L\" at the end.');\r\n    }\r\n    if (address.includes('.')) {\r\n        throw new Error('Address format does not match requirements. Address includes invalid character: `.`.');\r\n    }\r\n    const addressString = address.slice(0, -1);\r\n    const addressNumber = new BigNum(addressString);\r\n    if (addressNumber.cmp(new BigNum(constants_1.MAX_ADDRESS_NUMBER)) > 0) {\r\n        throw new Error('Address format does not match requirements. Address out of maximum range.');\r\n    }\r\n    if (addressString !== addressNumber.toString(BASE_TEN)) {\r\n        throw new Error(\"Address string format does not match it's number representation.\");\r\n    }\r\n    return true;\r\n};\r\nexports.isGreaterThanZero = (amount) => amount.cmp(0) > 0;\r\nexports.isGreaterThanOrEqualToZero = (amount) => amount.cmp(0) >= 0;\r\nexports.isGreaterThanMaxTransactionAmount = (amount) => amount.cmp(constants_1.MAX_TRANSACTION_AMOUNT) > 0;\r\nexports.isGreaterThanMaxTransactionId = (id) => id.cmp(constants_1.MAX_TRANSACTION_ID) > 0;\r\nexports.isNumberString = (str) => {\r\n    if (typeof str !== 'string') {\r\n        return false;\r\n    }\r\n    return /^[0-9]+$/g.test(str);\r\n};\r\nexports.validateNonTransferAmount = (data) => exports.isNumberString(data) && data === '0';\r\nexports.validateTransferAmount = (data) => exports.isNumberString(data) &&\r\n    exports.isGreaterThanZero(new BigNum(data)) &&\r\n    !exports.isGreaterThanMaxTransactionAmount(new BigNum(data));\r\nexports.isValidTransferData = (data) => Buffer.byteLength(data, 'utf8') <= constants_1.MAX_TRANSFER_ASSET_DATA_LENGTH;\r\nexports.validateFee = (data) => exports.isNumberString(data) &&\r\n    exports.isGreaterThanOrEqualToZero(new BigNum(data)) &&\r\n    !exports.isGreaterThanMaxTransactionAmount(new BigNum(data));\r\nexports.isValidInteger = (num) => typeof num === 'number' ? Math.floor(num) === num : false;\r\nexports.isUnique = (values) => {\r\n    const unique = [...new Set(values)];\r\n    return unique.length === values.length;\r\n};\r\nexports.isValidNumber = (num) => {\r\n    if (typeof num === 'number') {\r\n        return true;\r\n    }\r\n    if (typeof num === 'string') {\r\n        return exports.isNumberString(num);\r\n    }\r\n    return false;\r\n};\r\n//# sourceMappingURL=validation.js.map"]},"metadata":{},"sourceType":"script"}