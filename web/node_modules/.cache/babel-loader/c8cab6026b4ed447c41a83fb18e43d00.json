{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst BigNum = require(\"@liskhq/bignum\");\n\nconst cryptography = require(\"@liskhq/lisk-cryptography\");\n\nconst constants_1 = require(\"../constants\");\n\nexports.isValidValue = value => {\n  if (value === undefined) {\n    return false;\n  }\n\n  if (typeof value === 'number' && Number.isNaN(value)) {\n    return false;\n  }\n\n  if (value === false) {\n    return false;\n  }\n\n  return true;\n};\n\nexports.checkRequiredFields = (requiredFields, data) => {\n  const dataFields = Object.keys(data);\n  requiredFields.forEach(parameter => {\n    if (!dataFields.includes(parameter) || !exports.isValidValue(data[parameter])) {\n      throw new Error(`${parameter} is a required parameter.`);\n    }\n  });\n  return true;\n};\n\nexports.getAssetDataForTransferTransaction = ({\n  data\n}) => data ? Buffer.from(data, 'utf8') : Buffer.alloc(0);\n\nexports.getAssetDataForRegisterSecondSignatureTransaction = ({\n  signature\n}) => {\n  exports.checkRequiredFields(['publicKey'], signature);\n  const {\n    publicKey\n  } = signature;\n  return cryptography.hexToBuffer(publicKey);\n};\n\nexports.getAssetDataForRegisterDelegateTransaction = ({\n  delegate\n}) => {\n  exports.checkRequiredFields(['username'], delegate);\n  const {\n    username\n  } = delegate;\n  return Buffer.from(username, 'utf8');\n};\n\nexports.getAssetDataForCastVotesTransaction = ({\n  votes\n}) => {\n  if (!Array.isArray(votes)) {\n    throw new Error('votes parameter must be an Array.');\n  }\n\n  return Buffer.from(votes.join(''), 'utf8');\n};\n\nexports.getAssetDataForRegisterMultisignatureAccountTransaction = ({\n  multisignature\n}) => {\n  exports.checkRequiredFields(['min', 'lifetime', 'keysgroup'], multisignature);\n  const {\n    min,\n    lifetime,\n    keysgroup\n  } = multisignature;\n  const minBuffer = Buffer.alloc(1, min);\n  const lifetimeBuffer = Buffer.alloc(1, lifetime);\n  const keysgroupBuffer = Buffer.from(keysgroup.join(''), 'utf8');\n  return Buffer.concat([minBuffer, lifetimeBuffer, keysgroupBuffer]);\n};\n\nconst DAPP_TYPE_LENGTH = 4;\nconst DAPP_CATEGORY_LENGTH = 4;\n\nexports.getAssetDataForCreateDappTransaction = ({\n  dapp\n}) => {\n  exports.checkRequiredFields(['name', 'link', 'type', 'category'], dapp);\n  const {\n    name,\n    description,\n    tags,\n    link,\n    icon,\n    type,\n    category\n  } = dapp;\n  const nameBuffer = Buffer.from(name, 'utf8');\n  const linkBuffer = Buffer.from(link, 'utf8');\n  const typeBuffer = Buffer.alloc(DAPP_TYPE_LENGTH);\n  typeBuffer.writeIntLE(type, 0, DAPP_TYPE_LENGTH);\n  const categoryBuffer = Buffer.alloc(DAPP_CATEGORY_LENGTH);\n  categoryBuffer.writeIntLE(category, 0, DAPP_CATEGORY_LENGTH);\n  const descriptionBuffer = description ? Buffer.from(description, 'utf8') : Buffer.alloc(0);\n  const tagsBuffer = tags ? Buffer.from(tags, 'utf8') : Buffer.alloc(0);\n  const iconBuffer = icon ? Buffer.from(icon, 'utf8') : Buffer.alloc(0);\n  return Buffer.concat([nameBuffer, descriptionBuffer, tagsBuffer, linkBuffer, iconBuffer, typeBuffer, categoryBuffer]);\n};\n\nexports.getAssetDataForTransferIntoDappTransaction = ({\n  inTransfer\n}) => {\n  exports.checkRequiredFields(['dappId'], inTransfer);\n  const {\n    dappId\n  } = inTransfer;\n  return Buffer.from(dappId, 'utf8');\n};\n\nexports.getAssetDataForTransferOutOfDappTransaction = ({\n  outTransfer\n}) => {\n  exports.checkRequiredFields(['dappId', 'transactionId'], outTransfer);\n  const {\n    dappId,\n    transactionId\n  } = outTransfer;\n  const outAppIdBuffer = Buffer.from(dappId, 'utf8');\n  const outTransactionIdBuffer = Buffer.from(transactionId, 'utf8');\n  return Buffer.concat([outAppIdBuffer, outTransactionIdBuffer]);\n};\n\nconst transactionTypeAssetGetBytesMap = {\n  0: exports.getAssetDataForTransferTransaction,\n  1: exports.getAssetDataForRegisterSecondSignatureTransaction,\n  2: exports.getAssetDataForRegisterDelegateTransaction,\n  3: exports.getAssetDataForCastVotesTransaction,\n  4: exports.getAssetDataForRegisterMultisignatureAccountTransaction,\n  5: exports.getAssetDataForCreateDappTransaction,\n  6: exports.getAssetDataForTransferIntoDappTransaction,\n  7: exports.getAssetDataForTransferOutOfDappTransaction\n};\n\nexports.getAssetBytes = transaction => transactionTypeAssetGetBytesMap[transaction.type](transaction.asset);\n\nconst REQUIRED_TRANSACTION_PARAMETERS = ['type', 'timestamp', 'senderPublicKey', 'amount'];\n\nexports.checkTransaction = transaction => {\n  exports.checkRequiredFields(REQUIRED_TRANSACTION_PARAMETERS, transaction);\n  const {\n    data\n  } = transaction.asset;\n\n  if (data && data.length > constants_1.BYTESIZES.DATA) {\n    throw new Error(`Transaction asset data exceeds size of ${constants_1.BYTESIZES.DATA}.`);\n  }\n\n  return true;\n};\n\nexports.getTransactionBytes = transaction => {\n  exports.checkTransaction(transaction);\n  const {\n    type,\n    timestamp,\n    senderPublicKey,\n    recipientId,\n    amount,\n    signature,\n    signSignature\n  } = transaction;\n  const transactionType = Buffer.alloc(constants_1.BYTESIZES.TYPE, type);\n  const transactionTimestamp = Buffer.alloc(constants_1.BYTESIZES.TIMESTAMP);\n  transactionTimestamp.writeIntLE(timestamp, 0, constants_1.BYTESIZES.TIMESTAMP);\n  const transactionSenderPublicKey = cryptography.hexToBuffer(senderPublicKey);\n  const transactionRecipientID = recipientId ? cryptography.intToBuffer(recipientId.slice(0, -1), constants_1.BYTESIZES.RECIPIENT_ID) : Buffer.alloc(constants_1.BYTESIZES.RECIPIENT_ID);\n  const amountBigNum = new BigNum(amount);\n\n  if (amountBigNum.lt(0)) {\n    throw new Error('Transaction amount must not be negative.');\n  }\n\n  if (amountBigNum.gt(new BigNum(constants_1.MAX_TRANSACTION_AMOUNT))) {\n    throw new Error('Transaction amount is too large.');\n  }\n\n  const transactionAmount = amountBigNum.toBuffer({\n    endian: 'little',\n    size: constants_1.BYTESIZES.AMOUNT\n  });\n  const transactionAssetData = exports.getAssetBytes(transaction);\n  const transactionSignature = signature ? cryptography.hexToBuffer(signature) : Buffer.alloc(0);\n  const transactionSecondSignature = signSignature ? cryptography.hexToBuffer(signSignature) : Buffer.alloc(0);\n  return Buffer.concat([transactionType, transactionTimestamp, transactionSenderPublicKey, transactionRecipientID, transactionAmount, transactionAssetData, transactionSignature, transactionSecondSignature]);\n};","map":{"version":3,"sources":["../../src/utils/get_transaction_bytes.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst BigNum = require(\"@liskhq/bignum\");\r\nconst cryptography = require(\"@liskhq/lisk-cryptography\");\r\nconst constants_1 = require(\"../constants\");\r\nexports.isValidValue = (value) => {\r\n    if (value === undefined) {\r\n        return false;\r\n    }\r\n    if (typeof value === 'number' && Number.isNaN(value)) {\r\n        return false;\r\n    }\r\n    if (value === false) {\r\n        return false;\r\n    }\r\n    return true;\r\n};\r\nexports.checkRequiredFields = (requiredFields, data) => {\r\n    const dataFields = Object.keys(data);\r\n    requiredFields.forEach(parameter => {\r\n        if (!dataFields.includes(parameter) || !exports.isValidValue(data[parameter])) {\r\n            throw new Error(`${parameter} is a required parameter.`);\r\n        }\r\n    });\r\n    return true;\r\n};\r\nexports.getAssetDataForTransferTransaction = ({ data, }) => data ? Buffer.from(data, 'utf8') : Buffer.alloc(0);\r\nexports.getAssetDataForRegisterSecondSignatureTransaction = ({ signature, }) => {\r\n    exports.checkRequiredFields(['publicKey'], signature);\r\n    const { publicKey } = signature;\r\n    return cryptography.hexToBuffer(publicKey);\r\n};\r\nexports.getAssetDataForRegisterDelegateTransaction = ({ delegate, }) => {\r\n    exports.checkRequiredFields(['username'], delegate);\r\n    const { username } = delegate;\r\n    return Buffer.from(username, 'utf8');\r\n};\r\nexports.getAssetDataForCastVotesTransaction = ({ votes, }) => {\r\n    if (!Array.isArray(votes)) {\r\n        throw new Error('votes parameter must be an Array.');\r\n    }\r\n    return Buffer.from(votes.join(''), 'utf8');\r\n};\r\nexports.getAssetDataForRegisterMultisignatureAccountTransaction = ({ multisignature, }) => {\r\n    exports.checkRequiredFields(['min', 'lifetime', 'keysgroup'], multisignature);\r\n    const { min, lifetime, keysgroup } = multisignature;\r\n    const minBuffer = Buffer.alloc(1, min);\r\n    const lifetimeBuffer = Buffer.alloc(1, lifetime);\r\n    const keysgroupBuffer = Buffer.from(keysgroup.join(''), 'utf8');\r\n    return Buffer.concat([minBuffer, lifetimeBuffer, keysgroupBuffer]);\r\n};\r\nconst DAPP_TYPE_LENGTH = 4;\r\nconst DAPP_CATEGORY_LENGTH = 4;\r\nexports.getAssetDataForCreateDappTransaction = ({ dapp, }) => {\r\n    exports.checkRequiredFields(['name', 'link', 'type', 'category'], dapp);\r\n    const { name, description, tags, link, icon, type, category } = dapp;\r\n    const nameBuffer = Buffer.from(name, 'utf8');\r\n    const linkBuffer = Buffer.from(link, 'utf8');\r\n    const typeBuffer = Buffer.alloc(DAPP_TYPE_LENGTH);\r\n    typeBuffer.writeIntLE(type, 0, DAPP_TYPE_LENGTH);\r\n    const categoryBuffer = Buffer.alloc(DAPP_CATEGORY_LENGTH);\r\n    categoryBuffer.writeIntLE(category, 0, DAPP_CATEGORY_LENGTH);\r\n    const descriptionBuffer = description\r\n        ? Buffer.from(description, 'utf8')\r\n        : Buffer.alloc(0);\r\n    const tagsBuffer = tags ? Buffer.from(tags, 'utf8') : Buffer.alloc(0);\r\n    const iconBuffer = icon ? Buffer.from(icon, 'utf8') : Buffer.alloc(0);\r\n    return Buffer.concat([\r\n        nameBuffer,\r\n        descriptionBuffer,\r\n        tagsBuffer,\r\n        linkBuffer,\r\n        iconBuffer,\r\n        typeBuffer,\r\n        categoryBuffer,\r\n    ]);\r\n};\r\nexports.getAssetDataForTransferIntoDappTransaction = ({ inTransfer, }) => {\r\n    exports.checkRequiredFields(['dappId'], inTransfer);\r\n    const { dappId } = inTransfer;\r\n    return Buffer.from(dappId, 'utf8');\r\n};\r\nexports.getAssetDataForTransferOutOfDappTransaction = ({ outTransfer, }) => {\r\n    exports.checkRequiredFields(['dappId', 'transactionId'], outTransfer);\r\n    const { dappId, transactionId } = outTransfer;\r\n    const outAppIdBuffer = Buffer.from(dappId, 'utf8');\r\n    const outTransactionIdBuffer = Buffer.from(transactionId, 'utf8');\r\n    return Buffer.concat([outAppIdBuffer, outTransactionIdBuffer]);\r\n};\r\nconst transactionTypeAssetGetBytesMap = {\r\n    0: exports.getAssetDataForTransferTransaction,\r\n    1: exports.getAssetDataForRegisterSecondSignatureTransaction,\r\n    2: exports.getAssetDataForRegisterDelegateTransaction,\r\n    3: exports.getAssetDataForCastVotesTransaction,\r\n    4: exports.getAssetDataForRegisterMultisignatureAccountTransaction,\r\n    5: exports.getAssetDataForCreateDappTransaction,\r\n    6: exports.getAssetDataForTransferIntoDappTransaction,\r\n    7: exports.getAssetDataForTransferOutOfDappTransaction,\r\n};\r\nexports.getAssetBytes = (transaction) => transactionTypeAssetGetBytesMap[transaction.type](transaction.asset);\r\nconst REQUIRED_TRANSACTION_PARAMETERS = [\r\n    'type',\r\n    'timestamp',\r\n    'senderPublicKey',\r\n    'amount',\r\n];\r\nexports.checkTransaction = (transaction) => {\r\n    exports.checkRequiredFields(REQUIRED_TRANSACTION_PARAMETERS, transaction);\r\n    const { data } = transaction.asset;\r\n    if (data && data.length > constants_1.BYTESIZES.DATA) {\r\n        throw new Error(`Transaction asset data exceeds size of ${constants_1.BYTESIZES.DATA}.`);\r\n    }\r\n    return true;\r\n};\r\nexports.getTransactionBytes = (transaction) => {\r\n    exports.checkTransaction(transaction);\r\n    const { type, timestamp, senderPublicKey, recipientId, amount, signature, signSignature, } = transaction;\r\n    const transactionType = Buffer.alloc(constants_1.BYTESIZES.TYPE, type);\r\n    const transactionTimestamp = Buffer.alloc(constants_1.BYTESIZES.TIMESTAMP);\r\n    transactionTimestamp.writeIntLE(timestamp, 0, constants_1.BYTESIZES.TIMESTAMP);\r\n    const transactionSenderPublicKey = cryptography.hexToBuffer(senderPublicKey);\r\n    const transactionRecipientID = recipientId\r\n        ? cryptography.intToBuffer(recipientId.slice(0, -1), constants_1.BYTESIZES.RECIPIENT_ID)\r\n        : Buffer.alloc(constants_1.BYTESIZES.RECIPIENT_ID);\r\n    const amountBigNum = new BigNum(amount);\r\n    if (amountBigNum.lt(0)) {\r\n        throw new Error('Transaction amount must not be negative.');\r\n    }\r\n    if (amountBigNum.gt(new BigNum(constants_1.MAX_TRANSACTION_AMOUNT))) {\r\n        throw new Error('Transaction amount is too large.');\r\n    }\r\n    const transactionAmount = amountBigNum.toBuffer({\r\n        endian: 'little',\r\n        size: constants_1.BYTESIZES.AMOUNT,\r\n    });\r\n    const transactionAssetData = exports.getAssetBytes(transaction);\r\n    const transactionSignature = signature\r\n        ? cryptography.hexToBuffer(signature)\r\n        : Buffer.alloc(0);\r\n    const transactionSecondSignature = signSignature\r\n        ? cryptography.hexToBuffer(signSignature)\r\n        : Buffer.alloc(0);\r\n    return Buffer.concat([\r\n        transactionType,\r\n        transactionTimestamp,\r\n        transactionSenderPublicKey,\r\n        transactionRecipientID,\r\n        transactionAmount,\r\n        transactionAssetData,\r\n        transactionSignature,\r\n        transactionSecondSignature,\r\n    ]);\r\n};\r\n//# sourceMappingURL=get_transaction_bytes.js.map"]},"metadata":{},"sourceType":"script"}