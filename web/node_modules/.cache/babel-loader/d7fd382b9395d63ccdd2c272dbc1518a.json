{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst reverse = require(\"buffer-reverse\");\n\nconst ed2curve = require(\"ed2curve\");\n\nconst querystring = require(\"querystring\");\n\nconst buffer_1 = require(\"./buffer\");\n\nconst hash_1 = require(\"./hash\");\n\nexports.getFirstEightBytesReversed = input => {\n  const BUFFER_SIZE = 8;\n\n  if (typeof input === 'string') {\n    return reverse(Buffer.from(input).slice(0, BUFFER_SIZE));\n  }\n\n  return reverse(Buffer.from(input).slice(0, BUFFER_SIZE));\n};\n\nexports.toAddress = buffer => {\n  const BUFFER_SIZE = 8;\n\n  if (!Buffer.from(buffer).slice(0, BUFFER_SIZE).equals(buffer)) {\n    throw new Error('The buffer for Lisk addresses must not have more than 8 bytes');\n  }\n\n  return `${buffer_1.bufferToIntAsString(buffer)}L`;\n};\n\nexports.getAddressFromPublicKey = publicKey => {\n  const publicKeyHash = hash_1.hash(publicKey, 'hex');\n  const publicKeyTransform = exports.getFirstEightBytesReversed(publicKeyHash);\n  const address = exports.toAddress(publicKeyTransform);\n  return address;\n};\n\nexports.convertPublicKeyEd2Curve = ed2curve.convertPublicKey;\nexports.convertPrivateKeyEd2Curve = ed2curve.convertSecretKey;\n\nexports.stringifyEncryptedPassphrase = encryptedPassphrase => {\n  if (typeof encryptedPassphrase !== 'object' || encryptedPassphrase === null) {\n    throw new Error('Encrypted passphrase to stringify must be an object.');\n  }\n\n  const objectToStringify = encryptedPassphrase.iterations ? encryptedPassphrase : {\n    salt: encryptedPassphrase.salt,\n    cipherText: encryptedPassphrase.cipherText,\n    iv: encryptedPassphrase.iv,\n    tag: encryptedPassphrase.tag,\n    version: encryptedPassphrase.version\n  };\n  return querystring.stringify(objectToStringify);\n};\n\nconst parseIterations = iterationsString => {\n  const iterations = iterationsString === undefined ? undefined : parseInt(iterationsString, 10);\n\n  if (typeof iterations !== 'undefined' && Number.isNaN(iterations)) {\n    throw new Error('Could not parse iterations.');\n  }\n\n  return iterations;\n};\n\nexports.parseEncryptedPassphrase = encryptedPassphrase => {\n  if (typeof encryptedPassphrase !== 'string') {\n    throw new Error('Encrypted passphrase to parse must be a string.');\n  }\n\n  const keyValuePairs = querystring.parse(encryptedPassphrase);\n  const {\n    iterations,\n    salt,\n    cipherText,\n    iv,\n    tag,\n    version\n  } = keyValuePairs;\n\n  if (typeof iterations !== 'string' && typeof iterations !== 'undefined' || typeof salt !== 'string' || typeof cipherText !== 'string' || typeof iv !== 'string' || typeof tag !== 'string' || typeof version !== 'string') {\n    throw new Error('Encrypted passphrase to parse must have only one value per key.');\n  }\n\n  return {\n    iterations: parseIterations(iterations),\n    salt,\n    cipherText,\n    iv,\n    tag,\n    version\n  };\n};","map":{"version":3,"sources":["../src/convert.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst reverse = require(\"buffer-reverse\");\r\nconst ed2curve = require(\"ed2curve\");\r\nconst querystring = require(\"querystring\");\r\nconst buffer_1 = require(\"./buffer\");\r\nconst hash_1 = require(\"./hash\");\r\nexports.getFirstEightBytesReversed = (input) => {\r\n    const BUFFER_SIZE = 8;\r\n    if (typeof input === 'string') {\r\n        return reverse(Buffer.from(input).slice(0, BUFFER_SIZE));\r\n    }\r\n    return reverse(Buffer.from(input).slice(0, BUFFER_SIZE));\r\n};\r\nexports.toAddress = (buffer) => {\r\n    const BUFFER_SIZE = 8;\r\n    if (!Buffer.from(buffer)\r\n        .slice(0, BUFFER_SIZE)\r\n        .equals(buffer)) {\r\n        throw new Error('The buffer for Lisk addresses must not have more than 8 bytes');\r\n    }\r\n    return `${buffer_1.bufferToIntAsString(buffer)}L`;\r\n};\r\nexports.getAddressFromPublicKey = (publicKey) => {\r\n    const publicKeyHash = hash_1.hash(publicKey, 'hex');\r\n    const publicKeyTransform = exports.getFirstEightBytesReversed(publicKeyHash);\r\n    const address = exports.toAddress(publicKeyTransform);\r\n    return address;\r\n};\r\nexports.convertPublicKeyEd2Curve = ed2curve.convertPublicKey;\r\nexports.convertPrivateKeyEd2Curve = ed2curve.convertSecretKey;\r\nexports.stringifyEncryptedPassphrase = (encryptedPassphrase) => {\r\n    if (typeof encryptedPassphrase !== 'object' || encryptedPassphrase === null) {\r\n        throw new Error('Encrypted passphrase to stringify must be an object.');\r\n    }\r\n    const objectToStringify = encryptedPassphrase.iterations\r\n        ? encryptedPassphrase\r\n        : {\r\n            salt: encryptedPassphrase.salt,\r\n            cipherText: encryptedPassphrase.cipherText,\r\n            iv: encryptedPassphrase.iv,\r\n            tag: encryptedPassphrase.tag,\r\n            version: encryptedPassphrase.version,\r\n        };\r\n    return querystring.stringify(objectToStringify);\r\n};\r\nconst parseIterations = (iterationsString) => {\r\n    const iterations = iterationsString === undefined ? undefined : parseInt(iterationsString, 10);\r\n    if (typeof iterations !== 'undefined' && Number.isNaN(iterations)) {\r\n        throw new Error('Could not parse iterations.');\r\n    }\r\n    return iterations;\r\n};\r\nexports.parseEncryptedPassphrase = (encryptedPassphrase) => {\r\n    if (typeof encryptedPassphrase !== 'string') {\r\n        throw new Error('Encrypted passphrase to parse must be a string.');\r\n    }\r\n    const keyValuePairs = querystring.parse(encryptedPassphrase);\r\n    const { iterations, salt, cipherText, iv, tag, version } = keyValuePairs;\r\n    if ((typeof iterations !== 'string' && typeof iterations !== 'undefined') ||\r\n        typeof salt !== 'string' ||\r\n        typeof cipherText !== 'string' ||\r\n        typeof iv !== 'string' ||\r\n        typeof tag !== 'string' ||\r\n        typeof version !== 'string') {\r\n        throw new Error('Encrypted passphrase to parse must have only one value per key.');\r\n    }\r\n    return {\r\n        iterations: parseIterations(iterations),\r\n        salt,\r\n        cipherText,\r\n        iv,\r\n        tag,\r\n        version,\r\n    };\r\n};\r\n//# sourceMappingURL=convert.js.map"]},"metadata":{},"sourceType":"script"}