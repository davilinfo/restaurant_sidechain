{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst BigNum = require(\"@liskhq/bignum\");\n\nconst lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\n\nconst constants_1 = require(\"./constants\");\n\nconst errors_1 = require(\"./errors\");\n\nconst response_1 = require(\"./response\");\n\nconst utils_1 = require(\"./utils\");\n\nconst schemas = require(\"./utils/validation/schema\");\n\nvar MultisignatureStatus;\n\n(function (MultisignatureStatus) {\n  MultisignatureStatus[MultisignatureStatus[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  MultisignatureStatus[MultisignatureStatus[\"NONMULTISIGNATURE\"] = 1] = \"NONMULTISIGNATURE\";\n  MultisignatureStatus[MultisignatureStatus[\"PENDING\"] = 2] = \"PENDING\";\n  MultisignatureStatus[MultisignatureStatus[\"READY\"] = 3] = \"READY\";\n  MultisignatureStatus[MultisignatureStatus[\"FAIL\"] = 4] = \"FAIL\";\n})(MultisignatureStatus = exports.MultisignatureStatus || (exports.MultisignatureStatus = {}));\n\nexports.ENTITY_ACCOUNT = 'account';\nexports.ENTITY_TRANSACTION = 'transaction';\n\nclass BaseTransaction {\n  constructor(rawTransaction) {\n    this._multisignatureStatus = MultisignatureStatus.UNKNOWN;\n    const tx = typeof rawTransaction === 'object' && rawTransaction !== null ? rawTransaction : {};\n    this.amount = new BigNum(utils_1.isValidNumber(tx.amount) ? tx.amount : '0');\n    this.fee = new BigNum(utils_1.isValidNumber(tx.fee) ? tx.fee : this.constructor.FEE);\n    this.type = typeof tx.type === 'number' ? tx.type : this.constructor.TYPE;\n    this._id = tx.id;\n    this.recipientId = tx.recipientId || '';\n    this.recipientPublicKey = tx.recipientPublicKey || undefined;\n    this._senderPublicKey = tx.senderPublicKey || '';\n\n    try {\n      this._senderId = tx.senderId ? tx.senderId : lisk_cryptography_1.getAddressFromPublicKey(this.senderPublicKey);\n    } catch (error) {\n      this._senderId = '';\n    }\n\n    this._signature = tx.signature;\n    this.signatures = tx.signatures || [];\n    this._signSignature = tx.signSignature;\n    this.timestamp = typeof tx.timestamp === 'number' ? tx.timestamp : 0;\n    this.confirmations = tx.confirmations;\n    this.blockId = tx.blockId;\n    this.height = tx.height;\n    this.receivedAt = tx.receivedAt ? new Date(tx.receivedAt) : undefined;\n    this.relays = typeof tx.relays === 'number' ? tx.relays : undefined;\n    this.asset = tx.asset || {};\n  }\n\n  get id() {\n    if (!this._id) {\n      throw new Error('id is required to be set before use');\n    }\n\n    return this._id;\n  }\n\n  get senderId() {\n    if (!this._senderId) {\n      throw new Error('senderId is required to be set before use');\n    }\n\n    return this._senderId;\n  }\n\n  get senderPublicKey() {\n    if (!this._senderPublicKey) {\n      throw new Error('senderPublicKey is required to be set before use');\n    }\n\n    return this._senderPublicKey;\n  }\n\n  get signature() {\n    if (!this._signature) {\n      throw new Error('signature is required to be set before use');\n    }\n\n    return this._signature;\n  }\n\n  get signSignature() {\n    return this._signSignature;\n  }\n\n  toJSON() {\n    const transaction = {\n      id: this.id,\n      blockId: this.blockId,\n      height: this.height,\n      relays: this.relays,\n      confirmations: this.confirmations,\n      amount: this.amount.toString(),\n      type: this.type,\n      timestamp: this.timestamp,\n      senderPublicKey: this.senderPublicKey,\n      senderId: this.senderId,\n      recipientId: this.recipientId,\n      recipientPublicKey: this.recipientPublicKey,\n      fee: this.fee.toString(),\n      signature: this.signature,\n      signSignature: this.signSignature ? this.signSignature : undefined,\n      signatures: this.signatures,\n      asset: this.assetToJSON(),\n      receivedAt: this.receivedAt ? this.receivedAt.toISOString() : undefined\n    };\n    return transaction;\n  }\n\n  stringify() {\n    return JSON.stringify(this.toJSON());\n  }\n\n  isReady() {\n    return this._multisignatureStatus === MultisignatureStatus.READY || this._multisignatureStatus === MultisignatureStatus.NONMULTISIGNATURE;\n  }\n\n  getBytes() {\n    const transactionBytes = Buffer.concat([this.getBasicBytes(), this._signature ? lisk_cryptography_1.hexToBuffer(this._signature) : Buffer.alloc(0), this._signSignature ? lisk_cryptography_1.hexToBuffer(this._signSignature) : Buffer.alloc(0)]);\n    return transactionBytes;\n  }\n\n  validate() {\n    const errors = [...this._validateSchema(), ...this.validateAsset()];\n\n    if (errors.length > 0) {\n      return response_1.createResponse(this.id, errors);\n    }\n\n    const transactionBytes = this.getBasicBytes();\n    const {\n      valid: signatureValid,\n      error: verificationError\n    } = utils_1.validateSignature(this.senderPublicKey, this.signature, transactionBytes, this.id);\n\n    if (!signatureValid && verificationError) {\n      errors.push(verificationError);\n    }\n\n    const idError = utils_1.validateTransactionId(this.id, this.getBytes());\n\n    if (idError) {\n      errors.push(idError);\n    }\n\n    if (this.type !== this.constructor.TYPE) {\n      errors.push(new errors_1.TransactionError(`Invalid type`, this.id, '.type', this.type, this.constructor.TYPE));\n    }\n\n    const feeError = this.validateFee();\n\n    if (feeError) {\n      errors.push(feeError);\n    }\n\n    return response_1.createResponse(this.id, errors);\n  }\n\n  validateFee() {\n    return !this.fee.eq(this.constructor.FEE) ? new errors_1.TransactionError(`Invalid fee`, this.id, '.fee', this.fee.toString(), this.constructor.FEE.toString()) : undefined;\n  }\n\n  verifyAgainstOtherTransactions(transactions) {\n    const errors = this.verifyAgainstTransactions(transactions);\n    return response_1.createResponse(this.id, errors);\n  }\n\n  apply(store) {\n    const sender = store.account.getOrDefault(this.senderId);\n\n    const errors = this._verify(sender);\n\n    const {\n      errors: multiSigError\n    } = this.processMultisignatures(store);\n\n    if (multiSigError) {\n      errors.push(...multiSigError);\n    }\n\n    const updatedBalance = new BigNum(sender.balance).sub(this.fee);\n    const updatedSender = Object.assign({}, sender, {\n      balance: updatedBalance.toString(),\n      publicKey: sender.publicKey || this.senderPublicKey\n    });\n    store.account.set(updatedSender.address, updatedSender);\n    const assetErrors = this.applyAsset(store);\n    errors.push(...assetErrors);\n\n    if (this._multisignatureStatus === MultisignatureStatus.PENDING && errors.length === 1 && errors[0] instanceof errors_1.TransactionPendingError) {\n      return {\n        id: this.id,\n        status: response_1.Status.PENDING,\n        errors\n      };\n    }\n\n    return response_1.createResponse(this.id, errors);\n  }\n\n  undo(store) {\n    const sender = store.account.getOrDefault(this.senderId);\n    const updatedBalance = new BigNum(sender.balance).add(this.fee);\n    const updatedAccount = Object.assign({}, sender, {\n      balance: updatedBalance.toString(),\n      publicKey: sender.publicKey || this.senderPublicKey\n    });\n    const errors = updatedBalance.lte(constants_1.MAX_TRANSACTION_AMOUNT) ? [] : [new errors_1.TransactionError('Invalid balance amount', this.id, '.balance', sender.balance, updatedBalance.toString())];\n    store.account.set(updatedAccount.address, updatedAccount);\n    const assetErrors = this.undoAsset(store);\n    errors.push(...assetErrors);\n    return response_1.createResponse(this.id, errors);\n  }\n\n  async prepare(store) {\n    await store.account.cache([{\n      address: this.senderId\n    }]);\n  }\n\n  addMultisignature(store, signatureObject) {\n    const account = store.account.get(this.senderId);\n\n    if (account.membersPublicKeys && !account.membersPublicKeys.includes(signatureObject.publicKey)) {\n      return response_1.createResponse(this.id, [new errors_1.TransactionError(`Public Key '${signatureObject.publicKey}' is not a member for account '${account.address}'.`, this.id)]);\n    }\n\n    if (this.signatures.includes(signatureObject.signature)) {\n      return response_1.createResponse(this.id, [new errors_1.TransactionError(`Signature '${signatureObject.signature}' already present in transaction.`, this.id)]);\n    }\n\n    const {\n      valid\n    } = utils_1.validateSignature(signatureObject.publicKey, signatureObject.signature, this.getBasicBytes(), this.id);\n\n    if (valid) {\n      this.signatures.push(signatureObject.signature);\n      return this.processMultisignatures(store);\n    }\n\n    const errors = valid ? [] : [new errors_1.TransactionError(`Failed to add signature '${signatureObject.signature}'.`, this.id, '.signatures')];\n    return response_1.createResponse(this.id, errors);\n  }\n\n  addVerifiedMultisignature(signature) {\n    if (!this.signatures.includes(signature)) {\n      this.signatures.push(signature);\n      return response_1.createResponse(this.id, []);\n    }\n\n    return response_1.createResponse(this.id, [new errors_1.TransactionError('Failed to add signature.', this.id, '.signatures')]);\n  }\n\n  processMultisignatures(store) {\n    const sender = store.account.get(this.senderId);\n    const transactionBytes = this.getBasicBytes();\n    const {\n      status,\n      errors\n    } = utils_1.verifyMultiSignatures(this.id, sender, this.signatures, transactionBytes);\n    this._multisignatureStatus = status;\n\n    if (this._multisignatureStatus === MultisignatureStatus.PENDING) {\n      return {\n        id: this.id,\n        status: response_1.Status.PENDING,\n        errors\n      };\n    }\n\n    return response_1.createResponse(this.id, errors);\n  }\n\n  isExpired(date = new Date()) {\n    if (!this.receivedAt) {\n      this.receivedAt = new Date();\n    }\n\n    const timeNow = Math.floor(date.getTime() / 1000);\n    const timeOut = this._multisignatureStatus === MultisignatureStatus.PENDING || this._multisignatureStatus === MultisignatureStatus.READY ? constants_1.UNCONFIRMED_MULTISIG_TRANSACTION_TIMEOUT : constants_1.UNCONFIRMED_TRANSACTION_TIMEOUT;\n    const timeElapsed = timeNow - Math.floor(this.receivedAt.getTime() / 1000);\n    return timeElapsed > timeOut;\n  }\n\n  sign(passphrase, secondPassphrase) {\n    const {\n      address,\n      publicKey\n    } = lisk_cryptography_1.getAddressAndPublicKeyFromPassphrase(passphrase);\n\n    if (this._senderId !== '' && this._senderId !== address) {\n      throw new Error('Transaction senderId does not match address from passphrase');\n    }\n\n    if (this._senderPublicKey !== '' && this._senderPublicKey !== publicKey) {\n      throw new Error('Transaction senderPublicKey does not match public key from passphrase');\n    }\n\n    this._senderId = address;\n    this._senderPublicKey = publicKey;\n    this._signature = undefined;\n    this._signSignature = undefined;\n    this._signature = lisk_cryptography_1.signData(lisk_cryptography_1.hash(this.getBytes()), passphrase);\n\n    if (secondPassphrase) {\n      this._signSignature = lisk_cryptography_1.signData(lisk_cryptography_1.hash(this.getBytes()), secondPassphrase);\n    }\n\n    this._id = utils_1.getId(this.getBytes());\n  }\n\n  fromSync(raw) {\n    const transactionJSON = {\n      id: raw.t_id,\n      height: raw.b_height,\n      blockId: raw.b_id || raw.t_blockId,\n      type: parseInt(raw.t_type, 10),\n      timestamp: parseInt(raw.t_timestamp, 10),\n      senderPublicKey: raw.t_senderPublicKey,\n      requesterPublicKey: raw.t_requesterPublicKey,\n      senderId: raw.t_senderId,\n      recipientId: raw.t_recipientId,\n      recipientPublicKey: raw.m_recipientPublicKey || null,\n      amount: raw.t_amount,\n      fee: raw.t_fee,\n      signature: raw.t_signature,\n      signSignature: raw.t_signSignature,\n      signatures: raw.t_signatures ? raw.t_signatures.split(',') : [],\n      confirmations: parseInt(raw.confirmations || 0, 10),\n      asset: {}\n    };\n    const transaction = Object.assign({}, transactionJSON, {\n      asset: this.assetFromSync(raw) || {}\n    });\n    return transaction;\n  }\n\n  getBasicBytes() {\n    const transactionType = Buffer.alloc(constants_1.BYTESIZES.TYPE, this.type);\n    const transactionTimestamp = Buffer.alloc(constants_1.BYTESIZES.TIMESTAMP);\n    transactionTimestamp.writeIntLE(this.timestamp, 0, constants_1.BYTESIZES.TIMESTAMP);\n    const transactionSenderPublicKey = lisk_cryptography_1.hexToBuffer(this.senderPublicKey);\n    const transactionRecipientID = this.recipientId ? lisk_cryptography_1.intToBuffer(this.recipientId.slice(0, -1), constants_1.BYTESIZES.RECIPIENT_ID).slice(0, constants_1.BYTESIZES.RECIPIENT_ID) : Buffer.alloc(constants_1.BYTESIZES.RECIPIENT_ID);\n    const transactionAmount = this.amount.toBuffer({\n      endian: 'little',\n      size: constants_1.BYTESIZES.AMOUNT\n    });\n    return Buffer.concat([transactionType, transactionTimestamp, transactionSenderPublicKey, transactionRecipientID, transactionAmount, this.assetToBytes()]);\n  }\n\n  assetToJSON() {\n    return this.asset;\n  }\n\n  assetToBytes() {\n    return Buffer.from(JSON.stringify(this.asset), 'utf-8');\n  }\n\n  _verify(sender) {\n    const secondSignatureTxBytes = Buffer.concat([this.getBasicBytes(), lisk_cryptography_1.hexToBuffer(this.signature)]);\n    return [utils_1.verifySenderPublicKey(this.id, sender, this.senderPublicKey), utils_1.verifySenderId(this.id, sender, this.senderId), utils_1.verifyBalance(this.id, sender, this.fee), utils_1.verifySecondSignature(this.id, sender, this.signSignature, secondSignatureTxBytes)].filter(Boolean);\n  }\n\n  _validateSchema() {\n    const transaction = this.toJSON();\n    utils_1.validator.validate(schemas.baseTransaction, transaction);\n    const errors = errors_1.convertToTransactionError(this.id, utils_1.validator.errors);\n\n    if (!errors.find(err => err.dataPath === '.senderPublicKey')) {\n      const senderIdError = utils_1.validateSenderIdAndPublicKey(this.id, this.senderId, this.senderPublicKey);\n\n      if (senderIdError) {\n        errors.push(senderIdError);\n      }\n    }\n\n    return errors;\n  }\n\n}\n\nBaseTransaction.FEE = '0';\nexports.BaseTransaction = BaseTransaction;","map":{"version":3,"sources":["../src/base_transaction.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nconst BigNum = require(\"@liskhq/bignum\");\r\nconst lisk_cryptography_1 = require(\"@liskhq/lisk-cryptography\");\r\nconst constants_1 = require(\"./constants\");\r\nconst errors_1 = require(\"./errors\");\r\nconst response_1 = require(\"./response\");\r\nconst utils_1 = require(\"./utils\");\r\nconst schemas = require(\"./utils/validation/schema\");\r\nvar MultisignatureStatus;\r\n(function (MultisignatureStatus) {\r\n    MultisignatureStatus[MultisignatureStatus[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\r\n    MultisignatureStatus[MultisignatureStatus[\"NONMULTISIGNATURE\"] = 1] = \"NONMULTISIGNATURE\";\r\n    MultisignatureStatus[MultisignatureStatus[\"PENDING\"] = 2] = \"PENDING\";\r\n    MultisignatureStatus[MultisignatureStatus[\"READY\"] = 3] = \"READY\";\r\n    MultisignatureStatus[MultisignatureStatus[\"FAIL\"] = 4] = \"FAIL\";\r\n})(MultisignatureStatus = exports.MultisignatureStatus || (exports.MultisignatureStatus = {}));\r\nexports.ENTITY_ACCOUNT = 'account';\r\nexports.ENTITY_TRANSACTION = 'transaction';\r\nclass BaseTransaction {\r\n    constructor(rawTransaction) {\r\n        this._multisignatureStatus = MultisignatureStatus.UNKNOWN;\r\n        const tx = (typeof rawTransaction === 'object' && rawTransaction !== null\r\n            ? rawTransaction\r\n            : {});\r\n        this.amount = new BigNum(utils_1.isValidNumber(tx.amount) ? tx.amount : '0');\r\n        this.fee = new BigNum(utils_1.isValidNumber(tx.fee)\r\n            ? tx.fee\r\n            : this.constructor.FEE);\r\n        this.type =\r\n            typeof tx.type === 'number'\r\n                ? tx.type\r\n                : this.constructor.TYPE;\r\n        this._id = tx.id;\r\n        this.recipientId = tx.recipientId || '';\r\n        this.recipientPublicKey = tx.recipientPublicKey || undefined;\r\n        this._senderPublicKey = tx.senderPublicKey || '';\r\n        try {\r\n            this._senderId = tx.senderId\r\n                ? tx.senderId\r\n                : lisk_cryptography_1.getAddressFromPublicKey(this.senderPublicKey);\r\n        }\r\n        catch (error) {\r\n            this._senderId = '';\r\n        }\r\n        this._signature = tx.signature;\r\n        this.signatures = tx.signatures || [];\r\n        this._signSignature = tx.signSignature;\r\n        this.timestamp = typeof tx.timestamp === 'number' ? tx.timestamp : 0;\r\n        this.confirmations = tx.confirmations;\r\n        this.blockId = tx.blockId;\r\n        this.height = tx.height;\r\n        this.receivedAt = tx.receivedAt ? new Date(tx.receivedAt) : undefined;\r\n        this.relays = typeof tx.relays === 'number' ? tx.relays : undefined;\r\n        this.asset = tx.asset || {};\r\n    }\r\n    get id() {\r\n        if (!this._id) {\r\n            throw new Error('id is required to be set before use');\r\n        }\r\n        return this._id;\r\n    }\r\n    get senderId() {\r\n        if (!this._senderId) {\r\n            throw new Error('senderId is required to be set before use');\r\n        }\r\n        return this._senderId;\r\n    }\r\n    get senderPublicKey() {\r\n        if (!this._senderPublicKey) {\r\n            throw new Error('senderPublicKey is required to be set before use');\r\n        }\r\n        return this._senderPublicKey;\r\n    }\r\n    get signature() {\r\n        if (!this._signature) {\r\n            throw new Error('signature is required to be set before use');\r\n        }\r\n        return this._signature;\r\n    }\r\n    get signSignature() {\r\n        return this._signSignature;\r\n    }\r\n    toJSON() {\r\n        const transaction = {\r\n            id: this.id,\r\n            blockId: this.blockId,\r\n            height: this.height,\r\n            relays: this.relays,\r\n            confirmations: this.confirmations,\r\n            amount: this.amount.toString(),\r\n            type: this.type,\r\n            timestamp: this.timestamp,\r\n            senderPublicKey: this.senderPublicKey,\r\n            senderId: this.senderId,\r\n            recipientId: this.recipientId,\r\n            recipientPublicKey: this.recipientPublicKey,\r\n            fee: this.fee.toString(),\r\n            signature: this.signature,\r\n            signSignature: this.signSignature ? this.signSignature : undefined,\r\n            signatures: this.signatures,\r\n            asset: this.assetToJSON(),\r\n            receivedAt: this.receivedAt ? this.receivedAt.toISOString() : undefined,\r\n        };\r\n        return transaction;\r\n    }\r\n    stringify() {\r\n        return JSON.stringify(this.toJSON());\r\n    }\r\n    isReady() {\r\n        return (this._multisignatureStatus === MultisignatureStatus.READY ||\r\n            this._multisignatureStatus === MultisignatureStatus.NONMULTISIGNATURE);\r\n    }\r\n    getBytes() {\r\n        const transactionBytes = Buffer.concat([\r\n            this.getBasicBytes(),\r\n            this._signature ? lisk_cryptography_1.hexToBuffer(this._signature) : Buffer.alloc(0),\r\n            this._signSignature ? lisk_cryptography_1.hexToBuffer(this._signSignature) : Buffer.alloc(0),\r\n        ]);\r\n        return transactionBytes;\r\n    }\r\n    validate() {\r\n        const errors = [...this._validateSchema(), ...this.validateAsset()];\r\n        if (errors.length > 0) {\r\n            return response_1.createResponse(this.id, errors);\r\n        }\r\n        const transactionBytes = this.getBasicBytes();\r\n        const { valid: signatureValid, error: verificationError, } = utils_1.validateSignature(this.senderPublicKey, this.signature, transactionBytes, this.id);\r\n        if (!signatureValid && verificationError) {\r\n            errors.push(verificationError);\r\n        }\r\n        const idError = utils_1.validateTransactionId(this.id, this.getBytes());\r\n        if (idError) {\r\n            errors.push(idError);\r\n        }\r\n        if (this.type !== this.constructor.TYPE) {\r\n            errors.push(new errors_1.TransactionError(`Invalid type`, this.id, '.type', this.type, this.constructor.TYPE));\r\n        }\r\n        const feeError = this.validateFee();\r\n        if (feeError) {\r\n            errors.push(feeError);\r\n        }\r\n        return response_1.createResponse(this.id, errors);\r\n    }\r\n    validateFee() {\r\n        return !this.fee.eq(this.constructor.FEE)\r\n            ? new errors_1.TransactionError(`Invalid fee`, this.id, '.fee', this.fee.toString(), this.constructor.FEE.toString())\r\n            : undefined;\r\n    }\r\n    verifyAgainstOtherTransactions(transactions) {\r\n        const errors = this.verifyAgainstTransactions(transactions);\r\n        return response_1.createResponse(this.id, errors);\r\n    }\r\n    apply(store) {\r\n        const sender = store.account.getOrDefault(this.senderId);\r\n        const errors = this._verify(sender);\r\n        const { errors: multiSigError } = this.processMultisignatures(store);\r\n        if (multiSigError) {\r\n            errors.push(...multiSigError);\r\n        }\r\n        const updatedBalance = new BigNum(sender.balance).sub(this.fee);\r\n        const updatedSender = Object.assign({}, sender, { balance: updatedBalance.toString(), publicKey: sender.publicKey || this.senderPublicKey });\r\n        store.account.set(updatedSender.address, updatedSender);\r\n        const assetErrors = this.applyAsset(store);\r\n        errors.push(...assetErrors);\r\n        if (this._multisignatureStatus === MultisignatureStatus.PENDING &&\r\n            errors.length === 1 &&\r\n            errors[0] instanceof errors_1.TransactionPendingError) {\r\n            return {\r\n                id: this.id,\r\n                status: response_1.Status.PENDING,\r\n                errors,\r\n            };\r\n        }\r\n        return response_1.createResponse(this.id, errors);\r\n    }\r\n    undo(store) {\r\n        const sender = store.account.getOrDefault(this.senderId);\r\n        const updatedBalance = new BigNum(sender.balance).add(this.fee);\r\n        const updatedAccount = Object.assign({}, sender, { balance: updatedBalance.toString(), publicKey: sender.publicKey || this.senderPublicKey });\r\n        const errors = updatedBalance.lte(constants_1.MAX_TRANSACTION_AMOUNT)\r\n            ? []\r\n            : [\r\n                new errors_1.TransactionError('Invalid balance amount', this.id, '.balance', sender.balance, updatedBalance.toString()),\r\n            ];\r\n        store.account.set(updatedAccount.address, updatedAccount);\r\n        const assetErrors = this.undoAsset(store);\r\n        errors.push(...assetErrors);\r\n        return response_1.createResponse(this.id, errors);\r\n    }\r\n    async prepare(store) {\r\n        await store.account.cache([\r\n            {\r\n                address: this.senderId,\r\n            },\r\n        ]);\r\n    }\r\n    addMultisignature(store, signatureObject) {\r\n        const account = store.account.get(this.senderId);\r\n        if (account.membersPublicKeys &&\r\n            !account.membersPublicKeys.includes(signatureObject.publicKey)) {\r\n            return response_1.createResponse(this.id, [\r\n                new errors_1.TransactionError(`Public Key '${signatureObject.publicKey}' is not a member for account '${account.address}'.`, this.id),\r\n            ]);\r\n        }\r\n        if (this.signatures.includes(signatureObject.signature)) {\r\n            return response_1.createResponse(this.id, [\r\n                new errors_1.TransactionError(`Signature '${signatureObject.signature}' already present in transaction.`, this.id),\r\n            ]);\r\n        }\r\n        const { valid } = utils_1.validateSignature(signatureObject.publicKey, signatureObject.signature, this.getBasicBytes(), this.id);\r\n        if (valid) {\r\n            this.signatures.push(signatureObject.signature);\r\n            return this.processMultisignatures(store);\r\n        }\r\n        const errors = valid\r\n            ? []\r\n            : [\r\n                new errors_1.TransactionError(`Failed to add signature '${signatureObject.signature}'.`, this.id, '.signatures'),\r\n            ];\r\n        return response_1.createResponse(this.id, errors);\r\n    }\r\n    addVerifiedMultisignature(signature) {\r\n        if (!this.signatures.includes(signature)) {\r\n            this.signatures.push(signature);\r\n            return response_1.createResponse(this.id, []);\r\n        }\r\n        return response_1.createResponse(this.id, [\r\n            new errors_1.TransactionError('Failed to add signature.', this.id, '.signatures'),\r\n        ]);\r\n    }\r\n    processMultisignatures(store) {\r\n        const sender = store.account.get(this.senderId);\r\n        const transactionBytes = this.getBasicBytes();\r\n        const { status, errors } = utils_1.verifyMultiSignatures(this.id, sender, this.signatures, transactionBytes);\r\n        this._multisignatureStatus = status;\r\n        if (this._multisignatureStatus === MultisignatureStatus.PENDING) {\r\n            return {\r\n                id: this.id,\r\n                status: response_1.Status.PENDING,\r\n                errors,\r\n            };\r\n        }\r\n        return response_1.createResponse(this.id, errors);\r\n    }\r\n    isExpired(date = new Date()) {\r\n        if (!this.receivedAt) {\r\n            this.receivedAt = new Date();\r\n        }\r\n        const timeNow = Math.floor(date.getTime() / 1000);\r\n        const timeOut = this._multisignatureStatus === MultisignatureStatus.PENDING ||\r\n            this._multisignatureStatus === MultisignatureStatus.READY\r\n            ? constants_1.UNCONFIRMED_MULTISIG_TRANSACTION_TIMEOUT\r\n            : constants_1.UNCONFIRMED_TRANSACTION_TIMEOUT;\r\n        const timeElapsed = timeNow - Math.floor(this.receivedAt.getTime() / 1000);\r\n        return timeElapsed > timeOut;\r\n    }\r\n    sign(passphrase, secondPassphrase) {\r\n        const { address, publicKey } = lisk_cryptography_1.getAddressAndPublicKeyFromPassphrase(passphrase);\r\n        if (this._senderId !== '' && this._senderId !== address) {\r\n            throw new Error('Transaction senderId does not match address from passphrase');\r\n        }\r\n        if (this._senderPublicKey !== '' && this._senderPublicKey !== publicKey) {\r\n            throw new Error('Transaction senderPublicKey does not match public key from passphrase');\r\n        }\r\n        this._senderId = address;\r\n        this._senderPublicKey = publicKey;\r\n        this._signature = undefined;\r\n        this._signSignature = undefined;\r\n        this._signature = lisk_cryptography_1.signData(lisk_cryptography_1.hash(this.getBytes()), passphrase);\r\n        if (secondPassphrase) {\r\n            this._signSignature = lisk_cryptography_1.signData(lisk_cryptography_1.hash(this.getBytes()), secondPassphrase);\r\n        }\r\n        this._id = utils_1.getId(this.getBytes());\r\n    }\r\n    fromSync(raw) {\r\n        const transactionJSON = {\r\n            id: raw.t_id,\r\n            height: raw.b_height,\r\n            blockId: raw.b_id || raw.t_blockId,\r\n            type: parseInt(raw.t_type, 10),\r\n            timestamp: parseInt(raw.t_timestamp, 10),\r\n            senderPublicKey: raw.t_senderPublicKey,\r\n            requesterPublicKey: raw.t_requesterPublicKey,\r\n            senderId: raw.t_senderId,\r\n            recipientId: raw.t_recipientId,\r\n            recipientPublicKey: raw.m_recipientPublicKey || null,\r\n            amount: raw.t_amount,\r\n            fee: raw.t_fee,\r\n            signature: raw.t_signature,\r\n            signSignature: raw.t_signSignature,\r\n            signatures: raw.t_signatures ? raw.t_signatures.split(',') : [],\r\n            confirmations: parseInt(raw.confirmations || 0, 10),\r\n            asset: {},\r\n        };\r\n        const transaction = Object.assign({}, transactionJSON, { asset: this.assetFromSync(raw) || {} });\r\n        return transaction;\r\n    }\r\n    getBasicBytes() {\r\n        const transactionType = Buffer.alloc(constants_1.BYTESIZES.TYPE, this.type);\r\n        const transactionTimestamp = Buffer.alloc(constants_1.BYTESIZES.TIMESTAMP);\r\n        transactionTimestamp.writeIntLE(this.timestamp, 0, constants_1.BYTESIZES.TIMESTAMP);\r\n        const transactionSenderPublicKey = lisk_cryptography_1.hexToBuffer(this.senderPublicKey);\r\n        const transactionRecipientID = this.recipientId\r\n            ? lisk_cryptography_1.intToBuffer(this.recipientId.slice(0, -1), constants_1.BYTESIZES.RECIPIENT_ID).slice(0, constants_1.BYTESIZES.RECIPIENT_ID)\r\n            : Buffer.alloc(constants_1.BYTESIZES.RECIPIENT_ID);\r\n        const transactionAmount = this.amount.toBuffer({\r\n            endian: 'little',\r\n            size: constants_1.BYTESIZES.AMOUNT,\r\n        });\r\n        return Buffer.concat([\r\n            transactionType,\r\n            transactionTimestamp,\r\n            transactionSenderPublicKey,\r\n            transactionRecipientID,\r\n            transactionAmount,\r\n            this.assetToBytes(),\r\n        ]);\r\n    }\r\n    assetToJSON() {\r\n        return this.asset;\r\n    }\r\n    assetToBytes() {\r\n        return Buffer.from(JSON.stringify(this.asset), 'utf-8');\r\n    }\r\n    _verify(sender) {\r\n        const secondSignatureTxBytes = Buffer.concat([\r\n            this.getBasicBytes(),\r\n            lisk_cryptography_1.hexToBuffer(this.signature),\r\n        ]);\r\n        return [\r\n            utils_1.verifySenderPublicKey(this.id, sender, this.senderPublicKey),\r\n            utils_1.verifySenderId(this.id, sender, this.senderId),\r\n            utils_1.verifyBalance(this.id, sender, this.fee),\r\n            utils_1.verifySecondSignature(this.id, sender, this.signSignature, secondSignatureTxBytes),\r\n        ].filter(Boolean);\r\n    }\r\n    _validateSchema() {\r\n        const transaction = this.toJSON();\r\n        utils_1.validator.validate(schemas.baseTransaction, transaction);\r\n        const errors = errors_1.convertToTransactionError(this.id, utils_1.validator.errors);\r\n        if (!errors.find((err) => err.dataPath === '.senderPublicKey')) {\r\n            const senderIdError = utils_1.validateSenderIdAndPublicKey(this.id, this.senderId, this.senderPublicKey);\r\n            if (senderIdError) {\r\n                errors.push(senderIdError);\r\n            }\r\n        }\r\n        return errors;\r\n    }\r\n}\r\nBaseTransaction.FEE = '0';\r\nexports.BaseTransaction = BaseTransaction;\r\n//# sourceMappingURL=base_transaction.js.map"]},"metadata":{},"sourceType":"script"}